# Звіт до практичного заняття №2

## Завдання 1: Аналіз переповнення time_t
### Суть завдання
Потрібно з'ясувати, яке максимальне значення може мати змінна типу time_t і коли вона переповниться. Також варто порівняти результат на 32-бітній та 64-бітній системі.

### Код програми 
(https://github.com/Masonishche/ASPZ_Pr2/blob/main/task1.c)

### Результат виконання (на 64-бітній системі)

![Знімок екрана 2025-06-05 123338](https://github.com/user-attachments/assets/bace9522-52dc-4faa-a5c2-fb7531690994)

### Висновок

На 64-бітних системах time_t не переповниться ще мільярди років. На 32-бітних — це відбудеться 19 січня 2038 року.


## Завдання 2_3: Розташування сегментів пам’яті

### Суть завдання
Визначити, де саме в памʼяті знаходяться різні типи змінних — глобальні, статичні, динамічні (купа) та локальні (стек).

### Код програми 

(https://github.com/Masonishche/ASPZ_Pr2/blob/main/task2_3.c)


### Pезультат
![Знімок екрана 2025-06-05 123705](https://github.com/user-attachments/assets/a947deef-cb42-40f5-a6e1-e152ccf31992)

### Аналіз рішення
   Стек — верхня частина памʼяті, змінна stack_var.
   
   Купа (heap) — виділяється через malloc, знаходиться нижче.
   
   Data segment — глобальні змінні з ініціалізацією (global_var).
   
   BSS segment — глобальні змінні без ініціалізації (static_var).
   
### Висновок
Стек знаходиться у верхній частині пам’яті та зменшується.

Купа росте знизу.

Глобальні змінні потрапляють у data або bss.

## Завдання 2_4: Аналіз стеку через gdb

### Суть завдання
Побудувати програму з вкладеними викликами функцій і за допомогою gdb або gstack подивитися стек (які функції викликались і в якому порядку).

### Код програми
(https://github.com/Masonishche/ASPZ_Pr2/blob/main/task2_4.c)

### Результат програми
![Знімок екрана 2025-06-05 123952](https://github.com/user-attachments/assets/82da4805-17c5-466d-ab8c-a53a3c934301)

### Висновок
Функції викликаються в стеку зверху вниз. GDB дозволяє переглядати порядок викликів.

## Завдання 2_5: Чи можна обійтись без IP?

### Відповідь
Ні, тому що саме instruction pointer (IP) визначає, яку інструкцію процесор виконує далі. Стек містить лише адреси повернення і дані, але не керує потоком програми.

## Завдання за варіантом №23: Сегментаційна помилка

### Суть завдання
Дослідіть поведінку програми при сегментації пам’яті.

### Код
(https://github.com/Masonishche/ASPZ_Pr2/blob/main/task23.c)

### Результат програми
![Знімок екрана 2025-06-05 124301](https://github.com/user-attachments/assets/929aa489-8d6e-4f40-a301-8ee9a8683342)

### Опист програми

Це завдання демонструє одну з найпоширеніших проблем у програмуванні на мові C — помилку сегментації пам’яті (segmentation fault). Програма створена спеціально для того, щоб викликати цю помилку, а також показати, як її можна перехопити та обробити.

У коді ми бачимо, що використовується функція signal, яка дозволяє задати обробник сигналів. У цьому випадку вона налаштована на перехоплення сигналу SIGSEGV, який виникає, коли програма намагається звернутися до недоступної області пам’яті. Це трапляється, наприклад, коли ми намагаємося записати значення за адресою, яка дорівнює NULL.

У функції main створюється вказівник ptr, який одразу ініціалізується як NULL. Потім програма намагається записати значення 123 за цією адресою. Оскільки NULL не вказує на жодну дійсну область пам’яті, операційна система зупиняє програму і надсилає сигнал SIGSEGV. Але завдяки встановленому обробнику сигналів, замість аварійного завершення, програма виводить повідомлення: "Caught signal 11 (Segmentation fault)" і завершується коректно.

Цей приклад ілюструє, як важливо правильно працювати з пам’яттю в C, і як можна використовувати механізми обробки сигналів для діагностики та безпечного завершення програми у випадку критичних помилок. Він також показує, що навіть простий запис у неправильну адресу може призвести до серйозних наслідків, тому програмістам потрібно бути дуже уважними при роботі з вказівниками.

### Висновок
Програма обробила помилку звернення до пам’яті через нульовий вказівник. Це типовий приклад сегментаційної помилки.

## Загальний висновок
У цьому занятті я навчився:

Визначати розміри та розташування сегментів пам’яті (text, data, bss, stack, heap).

Користуватись інструментами size, readelf, gdb.

Розуміти поведінку змінних при компіляції.

Обробляти помилки сегментації.

Аналізувати стек викликів програми.

Практика дозволила глибше зрозуміти, як працює пам’ять у C-програмах та яким чином операційна система керує сегментами.
